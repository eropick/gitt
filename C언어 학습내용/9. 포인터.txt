포인터: 가리키는 상태를 의미하는데 이것을 무엇을 가르키냐?
메모리의 주소를 가르킨다. 즉, 메모리의 주소를 참조하기 위해 포인터로 사용한다.

컴퓨터에 데이터(값)를 저장할 때는 그 데이터(값)를 저장하기 위한 메모리라는 공간이 필요하고
이러한 메모리 영역은 고유 주소를 통해 그 값에 접근한다.

데이터가 만들어지면 아래처럼 3가지의 값이 생긴다.

변수이름 = 데이터의 성질을 제일 잘 나타낼 수 있는 라벨을 붙이는 것
메모리 = 데이터를 저장하기 위한 공간
메모리 주소 = 메모리를 찾아갈 수 있는 고유 주소

우리가 기존에 주소를 알아내기 위해서는 변수에 주소연산자 &를 붙여
주소를 알아냈다. 이 주소의 값을 일반 변수에 할당할 수 있을까?
정답은 불가능하다. 이 주소를 할당하기 위해서는 포인터 변수에 할당해야한다.

포인터는 *로 표시하며 정수형 데이터의 주소라면 
정수형 포인터인 int* 형식의 변수에 주소를 할당한다.

즉, 포인터 변수의 선언은 int* 나 float* char* 과 같은 형식으로 선언한다.
그리고 들어가는 값은 주소가 들어가야 한다.

포인터 변수를 선언했으면 실제로 사용할 때 포인터 주소만 사용할 수 있는 것이 아니라
그 주소로 갔을 때 있는 데이터를 사용할 수도 있다.
int a = 5;
int* px = &a; 라고 포인터 변수를 선언했어도
px 자체만 사용하면 포인터 변수 => 주소값을 갖고 있지만
*px처럼 *를 붙여줄 경우 값을 참조할 수 있다.

배열과 포인터의 관계
ex) int n[5]; 배열에서 변수이름인 n은 배열의 가장 첫 요소인 n[0]을 가리키는 주소다.
따라서 포인터에 배열을 할당시킬 때는 
int* px = n; 와 같이 변수이름만을 사용해서 할당할 수 있다.  

문자열을 포인터 형태로 선언해서 처리할 수도 있다.
char *s = "hello";
C에서는 문자열 리터럴이 char의 배열이지만, 
C++에서는 const char의 배열이기 때문에 오류가 날 수 있다.
char *s =(char*)"hello"; 처럼 선언해주자.

2차원 배열과 포인터
배열의 이름 = 배열의 첫 요소를 가르키는 주소

2차원 배열을 임의로 만들어보자
int a[2][3]
a[0][0] ~ a[1][[2] 까지 배열이 있을 것이다. 

여기서 a가 가리키는 배열의 첫 주소는 a[0](행)이 되고
a[0](행)가 가리키는 배열의 첫 주소는 a[0][0]가 된다.
즉, a[0]는 배열의 행으로서 그 행의 첫 주소인 a[0][0]을 가리키게 된다.

따라서 배열 변수 이름을 저장하기위한 포인터 변수는
int* pa[2];
pa[0] = a[0] =>즉 a[0][0]의 주소값이 들어간 것
pa[1] = a[1] =>즉 a[1][0]의 주소값이 들어간 것

다중 포인터 혹은 이중포인터
int a,*x,**y;
a = 100;
x = &a;
y = &x;
y는 이중 포인터로 
**y => *(*y) 즉 포인터 변수를 할당하는 포인터 변수라고 할 수 있다.
똑같이 값에 대한 접근은 *y로 하며 주소값을 받는다. 
 
-------------------------------------------------------------------
실제로 이중포인터 선언을 한 뒤 배열을 할당하려고 하면
int a[2][3];
int** y;
y=a; 

a는 a[0]의 주소이고 a[0][0]를 가리키는 배열 포인터 *[n] 타입이므로
int **타입에 할당하려는게 맞지 않다고 에러가 뜬다. 또한

y=a[0]; 라고 했을 때 a[0]는 a[0][0]의 주소를 가리키는데 이는 int*타입이므로
int**에 int*할당하려는게 맞지 않다고 에러가 뜬다.

하지만 포인터도 형변환을 하면 할당할 수 있다.
y = (int**)a; 또는
y = (int**)a[0]; 와 같이 표현이 가능하다.
형변환을 한다고해서 주소값이 바뀌지는 않는다.
다만 형변환을 하게 되면 그 형태에 맞게 바뀌므로
배열의 주소를 형변환을 통해 넣게되면 자동으로
int*타입인 a[0][0][0]의 주소값만이 자동으로 할당되는 것이다.
따라서 역참조를 해보면 값이 나온다.

형변환을 안하고 할당이 되는 것은 형태가 맞는 것
int* y = a[0]; 와 같은 것 뿐이다.

int a[3]; 는 int* 형 포인터
int b[4][5]; 는 int(*)[5] 형 포인터이다.

&연산이라는 것은 피연산자를 가리키는 포인터를 반환하는데
&a는 int(*)[3] 포인터를 리턴하고
&b는 int(*)[4][5] 포인터를 리턴한다.
따라서 배열 이름에 &가 붙은 배열전체를 가리키는 포인터가 된다. 

