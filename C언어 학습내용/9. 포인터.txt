포인터: 가리키는 상태를 의미하는데 이것을 무엇을 가르키냐?
메모리의 주소를 가르킨다. 즉, 메모리의 주소를 참조하기 위해 포인터로 사용한다.

컴퓨터에 데이터(값)를 저장할 때는 그 데이터(값)를 저장하기 위한 메모리라는 공간이 필요하고
이러한 메모리 영역은 고유 주소를 통해 그 값에 접근한다.

데이터가 만들어지면 아래처럼 3가지의 값이 생긴다.

변수이름 = 데이터의 성질을 제일 잘 나타낼 수 있는 라벨을 붙이는 것
메모리 = 데이터를 저장하기 위한 공간
메모리 주소 = 메모리를 찾아갈 수 있는 고유 주소

우리가 기존에 주소를 알아내기 위해서는 변수에 주소연산자 &를 붙여
주소를 알아냈다. 이 주소의 값을 일반 변수에 할당할 수 있을까?
정답은 불가능하다. 이 주소를 할당하기 위해서는 포인터 변수에 할당해야한다.

포인터는 *로 표시하며 정수형 데이터의 주소라면 
정수형 포인터인 int* 형식의 변수에 주소를 할당한다.

즉, 포인터 변수의 선언은 int* 나 float* char* 과 같은 형식으로 선언한다.
그리고 들어가는 값은 주소가 들어가야 한다.

포인터 변수를 선언했으면 실제로 사용할 때 포인터 주소만 사용할 수 있는 것이 아니라
그 주소로 갔을 때 있는 데이터를 사용할 수도 있다.
int a = 5;
int* px = &a; 라고 포인터 변수를 선언했어도
px 자체만 사용하면 포인터 변수 => 주소값을 갖고 있지만
*px처럼 *를 붙여줄 경우 값을 참조할 수 있다.

배열과 포인터의 관계
ex) int n[5]; 배열에서 변수이름인 n은 배열의 가장 첫 요소인 n[0]을 가리키는 주소다.
따라서 포인터에 배열을 할당시킬 때는 
int* px = n; 와 같이 변수이름만을 사용해서 할당할 수 있다.  

문자열을 포인터 형태로 선언해서 처리할 수도 있다.
char *s = "hello";
C에서는 문자열 리터럴이 char의 배열이지만, 
C++에서는 const char의 배열이기 때문에 오류가 날 수 있다.
char *s =(char*)"hello"; 처럼 선언해주자.

2차원 배열과 포인터
배열의 이름 = 배열의 첫 요소를 가르키는 주소

2차원 배열을 임의로 만들어보자
int a[2][3]
a[0][0] ~ a[1][[2] 까지 배열이 있을 것이다. 

여기서 a가 가리키는 배열의 첫 주소는 a[0](행)이 되고
a[0](행)가 가리키는 배열의 첫 주소는 a[0][0]가 된다.
즉, a[0]는 배열의 행으로서 그 행의 첫 주소인 a[0][0]을 가리키게 된다.

따라서 배열 변수 이름을 저장하기위한 포인터 변수는
int* pa[2];
pa[0] = a[0] =>즉 a[0][0]의 주소값이 들어간 것
pa[1] = a[1] =>즉 a[1][0]의 주소값이 들어간 것

다중 포인터 혹은 이중포인터
int a,*x,**y;
a = 100;
x = &a;
y = &x;
y는 이중 포인터로 
**y => *(*y) 즉 포인터 변수를 할당하는 포인터 변수라고 할 수 있다.
똑같이 값에 대한 접근은 *y로 하며 주소값을 받는다. 

포인터에 대해 총정리

1.1 일반변수, 1차원 배열의 주소를 담을 때 -> 일반 포인터 * 1개만 사용.
int* pa; 
int a =100;
int b[3] = {1,2,3};
pa = &a; //변수의 주소 할당시
pa = b //배열의 이름은 배열 첫 요소의 주소
pa = &b[0] //배열 첫 요소의 주소

---------------------------------------------------
1.2 문자열을 포인터 형태로 선언할 때
char s[] = "hello"; or char* s = "hello"
char ps* = s; //s배열의 첫 주소가 저장됨. 

---------------------------------------------------
1.3 역참조

pa -> 일반 주소값
*pa -> 그 주소에 해당하는 int값(역참조)
s -> 일반 주소값이지만, %s 스트링으로 받을 경우 정상 문자열 출력
*s -> 그 주소에 해당하는 char값(역참조)

---------------------------------------------------
2.1 2차원 배열의 주소를 담을 때

아래글 요약
2차원배열을 담는 포인터: 형식 (*변수명)[가로크기];
단순 포인터 배열 형식* 변수명[배열크기];

우선 생각해 볼 것은 우리가 알고 있는 이중포인터가 있는데
1차원배열의 주소를 그냥 포인터에 담았다면 이중포인터에
2차원배열을 담을 수 있지 않을까이다.
정답은 자료형이 다르다며 에러가 난다.
int a[2][3];
int **ps = a; 는 성립하지 않는다.

배열의 이름은 배열의 첫 요소의 주소이다. 
그렇지만 2차원 배열 a의 타입은 int* [ ]; 타입이다.
따라서 다음과 같이 선언해준다.

int a[2][3] = { {1,2,3}, {4,5,6} };   //int a[세로][가로];
int (*pa)[3]; //형식 (*변수이름)[가로크기];
pa = a; //다음의 값이 성립한다.

pa를 출력해보면 a의 첫 요소의 주소인 a[0]의 주소를 갖고있으며 (pa == &a[0])
*pa로 역참조 할 경우 a[0][0]의 주소를 알 수 있고 (*pa == &a[0][0])
**pa로 두 번 역참조 할 경우 a[0][0]의 값임을 알 수 있다. (**pa == a[0][0])
또한 직접 출력해보면 &a[0] == &a[0][0]이 같음을 알 수 있다.

-> 배열이름 a는 a[0]의 주소 a[0]는 a[0][0]의 주소다.

즉, a라는 것은 a[0]주소를 가르키고 있으며 
a[0]라는 것은 a[0][0]라는 것을 가리키고 있는 포인터라고 할 수 있다.

a의 주소를 할당받은 포인터를 ++시킬 경우 어떻게 증가할까?
a라는 값은 a[0]의 주소를 나타낸다고 했다. a[0]는 행을 나타내며
행이 증가하게 되는 것이므로 a[1]의 주소로 변하게 된다.
그렇다면 *pa를 증가시키면 a[0][0]주소의 값을 하나 
증가시키는 것이므로 a[0][1]이 된다.

-------------------------------------------
2.2 
2차원 배열을 1차원 포인터 배열로 나눌 수도 있다.
int* pa[2]; -> 배열은 2개이고 주소를 담는 포인터 배열 형식이다.

pa[0] = a[0]; //0번째 요소에 a[0][0]의 주소를 할당한다.
pa[1] = a[1]; //1번째 요소에 a[1][0]의 주소를 할당한다.

그냥 단순하게 크기만 2인 주소 하나만을 할당하는 배열이므로
a-> a[0] -> a[0][0] 구조의 이중 포인터 구조를 가진 a는 넣을 수 없고
a[0]와 같이 a[0][0]의 단일 주소를 나타내는 포인터만 들어갈 수 있다.
따라서 int* pa;와 같이 선언해서 pa = a[0]라고 해도 오류가 나지 않는다는 점이다.
-------------------------------------------
2.3 여러 문자열을 포인터 배열로 선언
하나의 문자열을 포인터로 선언한 것처럼 동일하게 할 수 있다.

char *s[] = {"txt","msc","cvc"};
char **ps = s; // char **ps = {"txt","msc","cvc"}; 와 같이 할 수도 있다.

단일 포인터일때는 ps를 %s로 곧바로 문자열을 확인할 수 있었고,
%c일 경우 *ps 역참조로 하나씩 주소에 해당하는 char값을 얻었다.

이중 포인터에서는 ps는 이중적인 주소를 의미하게 되므로 주소값말고는
얻을 수 없다. 따라서 *ps역참조를 통해 문자열을 출력하고 **ps 두 번
역참조를 하면 단일 포인터때와 동일하게 %c값을 얻을 수 있다.

여기서 a -> a[0] -> a[0][0]  개념이 있었는데
a는 a[0]의 주소를 의미하고 a[0]은 a[0][0]의 주소를 의미한다는 것이다.
포인터로 a를 받았다면 그 포인터를 그냥 출력했을 때는 a[0]주소가 나올 것이고
역참조(그 a[0]가 가리키는 값의 의미)했다고 한다면 a[0][0]의 주소가 나올 것이며
한 번 더 역참조(a[0][0]의 값의 의미)한다면 a[0][0]의 값을 알 수 있다. 
 
 
